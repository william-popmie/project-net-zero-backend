{
  "project_root": "/Users/williamragnarsson/Documents/Programming/HackEurope/test/project-net-zero-backend/input-repo",
  "generated_at": "2026-02-21T20:36:53.660992",
  "coverage_threshold": 80.0,
  "functions": [
    {
      "id": "src.app.math_utils.add",
      "name": "add",
      "file": "src/app/math_utils.py",
      "function_code": "def add(a: int, b: int) -> int:\n    return a + b",
      "test_code": "def test_add_positive_numbers(self):\n    \"\"\"Test adding two positive integers.\"\"\"\n    assert add(2, 3) == 5\n\ndef test_add_negative_numbers(self):\n    \"\"\"Test adding two negative integers.\"\"\"\n    assert add(-2, -3) == -5\n\ndef test_add_positive_and_negative(self):\n    \"\"\"Test adding a positive and negative integer.\"\"\"\n    assert add(5, -3) == 2\n    assert add(-3, 5) == 2\n\ndef test_add_with_zero(self):\n    \"\"\"Test adding with zero.\"\"\"\n    assert add(0, 5) == 5\n    assert add(5, 0) == 5\n    assert add(0, 0) == 0\n\ndef test_add_large_numbers(self):\n    \"\"\"Test adding large integers.\"\"\"\n    assert add(1000000000, 2000000000) == 3000000000\n\ndef test_add_commutative_property(self):\n    \"\"\"Test that addition is commutative (a + b == b + a).\"\"\"\n    assert add(7, 3) == add(3, 7)\n\ndef test_add_negative_result(self):\n    \"\"\"Test addition resulting in a negative number.\"\"\"\n    assert add(-10, 3) == -7\n\n@pytest.mark.parametrize('a,b,expected', [(1, 1, 2), (0, 0, 0), (-1, 1, 0), (100, 200, 300), (-50, -50, -100)])\ndef test_add_parametrized(a, b, expected):\n    \"\"\"Parametrized test for various input combinations.\"\"\"\n    assert add(a, b) == expected",
      "test_file": "/Users/williamragnarsson/Documents/Programming/HackEurope/test/project-net-zero-backend/input-repo/tests/app/test_math_utils.py",
      "coverage_score": 100.0,
      "status": "passed_existing",
      "errors": []
    },
    {
      "id": "src.app.math_utils.multiply",
      "name": "multiply",
      "file": "src/app/math_utils.py",
      "function_code": "def multiply(a: int, b: int) -> int:\n    return a * b",
      "test_code": "def test_multiply_positive_numbers(self):\n    \"\"\"Test multiplication of two positive integers.\"\"\"\n    assert multiply(3, 4) == 12\n\ndef test_multiply_negative_numbers(self):\n    \"\"\"Test multiplication of two negative integers.\"\"\"\n    assert multiply(-3, -4) == 12\n\ndef test_multiply_mixed_sign_numbers(self):\n    \"\"\"Test multiplication of positive and negative integers.\"\"\"\n    assert multiply(-3, 4) == -12\n    assert multiply(3, -4) == -12\n\ndef test_multiply_by_zero(self):\n    \"\"\"Test multiplication by zero.\"\"\"\n    assert multiply(5, 0) == 0\n    assert multiply(0, 5) == 0\n    assert multiply(0, 0) == 0\n\ndef test_multiply_by_one(self):\n    \"\"\"Test multiplication by one (identity).\"\"\"\n    assert multiply(7, 1) == 7\n    assert multiply(1, 7) == 7\n    assert multiply(1, 1) == 1\n\ndef test_multiply_by_negative_one(self):\n    \"\"\"Test multiplication by negative one.\"\"\"\n    assert multiply(7, -1) == -7\n    assert multiply(-1, 7) == -7\n    assert multiply(-1, -1) == 1\n\ndef test_multiply_large_numbers(self):\n    \"\"\"Test multiplication of large integers.\"\"\"\n    assert multiply(1000000, 1000000) == 1000000000000\n\ndef test_multiply_commutative_property(self):\n    \"\"\"Test that multiplication is commutative (a * b == b * a).\"\"\"\n    assert multiply(5, 3) == multiply(3, 5)\n    assert multiply(-2, 7) == multiply(7, -2)\n\ndef test_multiply_associative_with_sequential_calls(self):\n    \"\"\"Test associative-like behavior with sequential multiplications.\"\"\"\n    result1 = multiply(multiply(2, 3), 4)\n    result2 = multiply(2, multiply(3, 4))\n    assert result1 == result2 == 24\n\n@pytest.mark.parametrize('a,b,expected', [(2, 3, 6), (0, 100, 0), (-5, -5, 25), (-10, 10, -100), (1, 999, 999), (100, 100, 10000)])\ndef test_multiply_parametrized(a, b, expected):\n    \"\"\"Parametrized test for various multiplication scenarios.\"\"\"\n    assert multiply(a, b) == expected",
      "test_file": "/Users/williamragnarsson/Documents/Programming/HackEurope/test/project-net-zero-backend/input-repo/tests/app/test_math_utils.py",
      "coverage_score": 100.0,
      "status": "passed_existing",
      "errors": []
    },
    {
      "id": "src.app.math_utils.subtract",
      "name": "subtract",
      "file": "src/app/math_utils.py",
      "function_code": "def subtract(a: int, b: int) -> int:\n    \"\"\"Subtract b from a.\"\"\"\n    return a - b",
      "test_code": "def test_subtract_positive_numbers():\n    \"\"\"Test subtraction of two positive numbers.\"\"\"\n    assert subtract(10, 3) == 7\n\ndef test_subtract_negative_numbers():\n    \"\"\"Test subtraction of two negative numbers.\"\"\"\n    assert subtract(-5, -3) == -2\n\ndef test_subtract_mixed_signs():\n    \"\"\"Test subtraction with mixed positive and negative numbers.\"\"\"\n    assert subtract(5, -3) == 8\n    assert subtract(-5, 3) == -8\n\ndef test_subtract_zero():\n    \"\"\"Test subtraction involving zero.\"\"\"\n    assert subtract(5, 0) == 5\n    assert subtract(0, 5) == -5\n    assert subtract(0, 0) == 0\n\ndef test_subtract_same_numbers():\n    \"\"\"Test subtracting a number from itself.\"\"\"\n    assert subtract(42, 42) == 0\n    assert subtract(-10, -10) == 0\n\ndef test_subtract_large_numbers():\n    \"\"\"Test subtraction with large numbers.\"\"\"\n    assert subtract(1000000, 999999) == 1\n    assert subtract(10 ** 10, 10 ** 9) == 9000000000\n\ndef test_subtract_result_negative():\n    \"\"\"Test subtraction resulting in a negative number.\"\"\"\n    assert subtract(3, 10) == -7\n\n@pytest.mark.parametrize('a, b, expected', [(100, 50, 50), (1, 1, 0), (-1, -1, 0), (0, -5, 5), (-100, 50, -150)])\ndef test_subtract_parametrized(a: int, b: int, expected: int):\n    \"\"\"Test subtraction with various input combinations.\"\"\"\n    assert subtract(a, b) == expected",
      "test_file": "/Users/williamragnarsson/Documents/Programming/HackEurope/test/project-net-zero-backend/input-repo/tests/app/test_math_utils.py",
      "coverage_score": 100.0,
      "status": "passed_existing",
      "errors": []
    },
    {
      "id": "src.app.math_utils.divide",
      "name": "divide",
      "file": "src/app/math_utils.py",
      "function_code": "def divide(a: float, b: float) -> float:\n    \"\"\"\n    Divide a by b.\n    \n    Raises:\n        ValueError: If b is zero.\n    \"\"\"\n    if b == 0:\n        raise ValueError('Cannot divide by zero')\n    return a / b",
      "test_code": "def test_divide_positive_numbers(self):\n    \"\"\"Test division of two positive numbers.\"\"\"\n    assert divide(10, 2) == 5.0\n\ndef test_divide_negative_numbers(self):\n    \"\"\"Test division of two negative numbers.\"\"\"\n    assert divide(-10, -2) == 5.0\n\ndef test_divide_positive_by_negative(self):\n    \"\"\"Test division of positive by negative number.\"\"\"\n    assert divide(10, -2) == -5.0\n\ndef test_divide_negative_by_positive(self):\n    \"\"\"Test division of negative by positive number.\"\"\"\n    assert divide(-10, 2) == -5.0\n\ndef test_divide_zero_by_number(self):\n    \"\"\"Test division of zero by a non-zero number.\"\"\"\n    assert divide(0, 5) == 0.0\n\ndef test_divide_returns_float(self):\n    \"\"\"Test that division returns a float.\"\"\"\n    result = divide(10, 4)\n    assert isinstance(result, float)\n    assert result == 2.5\n\ndef test_divide_with_floats(self):\n    \"\"\"Test division with float inputs.\"\"\"\n    assert divide(7.5, 2.5) == 3.0\n\ndef test_divide_with_mixed_int_and_float(self):\n    \"\"\"Test division with mixed integer and float inputs.\"\"\"\n    assert divide(10, 2.5) == 4.0\n    assert divide(7.5, 3) == 2.5\n\ndef test_divide_small_numbers(self):\n    \"\"\"Test division with small numbers.\"\"\"\n    result = divide(0.001, 0.001)\n    assert result == pytest.approx(1.0)\n\ndef test_divide_large_numbers(self):\n    \"\"\"Test division with large numbers.\"\"\"\n    assert divide(1000000, 1000) == 1000.0\n\ndef test_divide_by_zero_raises_value_error(self):\n    \"\"\"Test that dividing by zero raises ValueError.\"\"\"\n    with pytest.raises(ValueError) as exc_info:\n        divide(10, 0)\n    assert str(exc_info.value) == 'Cannot divide by zero'\n\ndef test_divide_zero_by_zero_raises_value_error(self):\n    \"\"\"Test that dividing zero by zero raises ValueError.\"\"\"\n    with pytest.raises(ValueError) as exc_info:\n        divide(0, 0)\n    assert str(exc_info.value) == 'Cannot divide by zero'\n\ndef test_divide_negative_by_zero_raises_value_error(self):\n    \"\"\"Test that dividing negative number by zero raises ValueError.\"\"\"\n    with pytest.raises(ValueError) as exc_info:\n        divide(-10, 0)\n    assert str(exc_info.value) == 'Cannot divide by zero'\n\ndef test_divide_by_zero_float_raises_value_error(self):\n    \"\"\"Test that dividing by zero as float raises ValueError.\"\"\"\n    with pytest.raises(ValueError) as exc_info:\n        divide(10, 0.0)\n    assert str(exc_info.value) == 'Cannot divide by zero'\n\ndef test_divide_result_precision(self):\n    \"\"\"Test division result precision for repeating decimals.\"\"\"\n    result = divide(1, 3)\n    assert result == pytest.approx(0.3333333333333333)\n\ndef test_divide_by_one(self):\n    \"\"\"Test division by one returns the dividend.\"\"\"\n    assert divide(42, 1) == 42.0\n    assert divide(-42, 1) == -42.0\n\ndef test_divide_by_negative_one(self):\n    \"\"\"Test division by negative one negates the dividend.\"\"\"\n    assert divide(42, -1) == -42.0\n    assert divide(-42, -1) == 42.0",
      "test_file": "/Users/williamragnarsson/Documents/Programming/HackEurope/test/project-net-zero-backend/input-repo/tests/app/test_math_utils.py",
      "coverage_score": 100.0,
      "status": "passed_existing",
      "errors": []
    }
  ]
}